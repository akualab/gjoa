package model

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"os"
	"path/filepath"
	"reflect"

	"github.com/golang/glog"
)

// A sample label.
type Labeler interface {

	// Human-readable name.
	Name() string

	// Unique id.
	Id() int

	// Compare labels.
	IsEqual(label Labeler) bool
}

// An observations.
type Obs interface {

	// The observation's value.
	Value() interface{}

	// The observation's label.
	Label() Labeler
}

// Data is represented as a sequence of objects that
// implement the Obs interface.
type Sampler interface {

	// Returns channel of observations. The sequence end when the
	// channel closes.
	Chan() (<-chan Obs, error)
}

// Model trainer.
type Trainer2 interface {

	// Updates model using weighted samples: x[i] * w(x[i]).
	Update(x Sampler, w func(Obs) float64) error

	// Estimates model parameters.
	Estimate() error

	// Clears all model parameters.
	Clear()
}

var NoWeight = func(o Obs) float64 { return 1.0 }

// Returns predicted label for data.
type Predictor interface {
	Predict(x Sampler) ([]Labeler, error)
}

// Returns score for data.
type Scorer interface {
	Score(x Sampler) ([]float64, error)
}

// A floating point slice observation that implements the Obs interface.
type FloatObs struct {
	value []float64
	label SimpleLabel
}

// Returns observation value.
func (fo FloatObs) Value() interface{} { return interface{}(fo.value) }

// Returns observation label.
func (fo FloatObs) Label() Labeler { return Labeler(fo.label) }

// Implements Labeler interface.
type SimpleLabel struct {
	name string
	val  int
}

// Returnes unique id.
func (lab SimpleLabel) Id() int {
	return lab.val
}

// Returns label name.
func (lab SimpleLabel) Name() string {
	return lab.name
}

// Returns true if labels are equal.
func (lab SimpleLabel) IsEqual(lab2 Labeler) bool {
	if lab.Id() == lab2.Id() {
		return true
	}
	return false
}

// Simple sampler for floating-point values.
// Not safe to use with multiple goroutines.
type FloatSampler struct {
	Values [][]float64
	Labels []SimpleLabel
	length int
}

func NewFloatSampler(v [][]float64, lab []SimpleLabel) (*FloatSampler, error) {
	if len(v) != len(lab) {
		return nil, fmt.Errorf("length of v [%d] and length of lab [%d] don't match.", len(v), len(lab))
	}
	return &FloatSampler{
		Values: v,
		Labels: lab,
		length: len(v),
	}, nil
}

// Returns channel of FloatObs as type Obs.
func (fs FloatSampler) Chan() (<-chan Obs, error) {

	obsChan := make(chan Obs, 1000)
	go func() {
		for i := 0; i < fs.length; i++ {
			obsChan <- Obs(FloatObs{fs.Values[i], fs.Labels[i]})
		}
		close(obsChan)
	}()

	return obsChan, nil
}

////////////////

var modelTypes = make(map[string]Modeler)

// All model types must register during initialization:
//
// func init() {
//	 m := new(MyModel)
//	 model.Register(m)
// }
func Register(model Modeler) {
	value := reflect.Indirect(reflect.ValueOf(model))
	name := value.Type().Name()
	modelTypes[name] = model
}

// Returns an uninitialized instance of the model.
func Model(typeName string) (Modeler, error) {

	t := modelTypes[typeName]
	if t == nil {
		return nil, fmt.Errorf("Unknown model typr [%s].", typeName)
	}
	return t, nil
}

// Returns a random observations generated by the model.
// obs is the random observation.
// sequence applies to Markov models.
type Generator interface {
	Random(r *rand.Rand) (obs interface{}, sequence []int, e error)
}

// A read-only model.
type Modeler interface {

	// Initializes model. Must be called to initialized private fields when
	// the model is created using a Read method.
	Initialize() error

	// Returns the probabilty of obs given the model.
	Prob(obs interface{}) float64

	// Returns the log probabilty of obs given the model.
	LogProb(obs interface{}) float64

	// The model name.
	Name() string

	// Dimensionality of the observation verctor.
	NumElements() int

	// True if the model is trainable.
	Trainable() bool

	Generator
}

// A trainable model.
type Trainer interface {
	Modeler

	Update(a []float64, w float64) error
	Estimate() error
	Clear() error
	SetName(name string)
	NumSamples() float64
}

// A trainable sequence model.
type SequenceTrainer interface {
	Modeler

	Update(seq [][]float64, w float64) error
	Estimate() error
	Clear() error
	SetName(name string)
	NumSamples() float64
}

// Implements basic functionality for models. Model implementations can embed
// this type. The field Base.Model must be initialized to point to the model
// implementation.
type BaseModel struct {
	Model     Modeler `json:"-"`
	ModelType string  `json:"type"`
}

func NewBaseModel(model Modeler) *BaseModel {

	value := reflect.Indirect(reflect.ValueOf(model))
	modelType := value.Type().Name()

	return &BaseModel{
		Model:     model,
		ModelType: modelType,
	}
}

// Unmarshals data into a struct. The original model instance is not modified.
// Returns a new model instance of the same type as the original.
func (base *BaseModel) Read(r io.Reader) (Modeler, error) {

	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	// Get a Modeler object.
	model := base.Model
	value := reflect.Indirect(reflect.ValueOf(model))
	o := reflect.New(value.Type()).Interface().(Modeler)
	e := json.Unmarshal(b, &o)

	if e != nil {
		return nil, e
	}
	o.Initialize()

	return o, nil
}

// Reads model data from file. See Read().
func (base *BaseModel) ReadFile(fn string) (Modeler, error) {

	f, err := os.Open(fn)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return base.Read(f)
}

// Writes model values to an io.Writer.
func (base *BaseModel) Write(w io.Writer) error {

	base.ModelType = base.Type()
	b, err := json.Marshal(base.Model)
	if err != nil {
		return err
	}
	_, e := w.Write(b)
	return e
}

// Writes model values to a file.
func (base *BaseModel) WriteFile(fn string) error {

	e := os.MkdirAll(filepath.Dir(fn), 0755)
	if e != nil {
		return e
	}
	f, err := os.Create(fn)
	if err != nil {
		return err
	}
	defer f.Close()

	ee := base.Write(f)
	if ee != nil {
		return ee
	}

	glog.Infof("Wrote model \"%s\" to file %s.", base.Model.Name(), fn)
	return nil
}

// Returns the model type as a string..
func (base *BaseModel) Type() string {

	model := base.Model
	value := reflect.Indirect(reflect.ValueOf(model))
	name := value.Type().Name()
	return name
}
